# Shot Creator Agent

## Overview
Shot creator breaks a story JSON file into shots which can be used to create video shots. This agent takes the story JSON file, goes through section by section and generates the shots based on the section. 

## Story Model

The Story model represents the complete narrative structure generated by the Story Creator Agent. It follows a hierarchical structure:

### Story
The top-level container for the entire narrative.

**Fields:**
- `title` (str): The title of the story
- `subject` (str): The subject or theme of the story
- `introduction` (Optional[Narration]): Opening narration to set the scene
- `quests` (list[Quest]): Collection of quests that make up the story
- `conclusion` (Optional[Narration]): Closing narration to wrap up the story

### Quest
Represents an individual quest within the story.

**Fields:**
- `title` (str): The title of the quest
- `sections` (QuestSection): The structured sections of the quest

### QuestSection
Contains the four narrative components of a quest.

**Fields:**
- `introduction` (Optional[Narration]): Narration introducing the quest
- `dialogue` (Optional[DialogueLines]): Dialogue when accepting the quest
- `execution` (Optional[Narration]): Narration during quest execution
- `completion` (Optional[DialogueLines]): Dialogue when completing the quest

### Narration
Represents narrative text content.

**Fields:**
- `text` (str): The narration text
- `word_count` (int): The number of words in the narration

### DialogueLines
Contains multiple dialogue exchanges.

**Fields:**
- `lines` (list[DialogueLine]): Collection of dialogue lines

### DialogueLine
Represents a single line of dialogue.

**Fields:**
- `actor` (str): The character speaking the line
- `line` (str): The dialogue text

### Story Structure Flow

```
Story
├── introduction (Narration)
├── quests[]
│   └── Quest
│       ├── title
│       └── sections
│           ├── introduction (Narration)
│           ├── dialogue (DialogueLines)
│           │   └── lines[]
│           │       └── DialogueLine
│           │           ├── actor
│           │           └── line
│           ├── execution (Narration)
│           └── completion (DialogueLines)
│               └── lines[]
│                   └── DialogueLine
│                       ├── actor
│                       └── line
└── conclusion (Narration)
```

## The Agent Workflow
The Shot Creator uses a two-phase approach: first chunking the entire story into processable chunks, then converting each chunk into a shot with AI-determined TTS and cinematography parameters.

```mermaid
flowchart TB
    Start[Start] --> LoadStory
    LoadStory[Load Story JSON] --> InitializeChunking
    InitializeChunking[Initialize Chunking] --> ProcessIntroduction
    ProcessIntroduction[Process Introduction] --> InitializeQuestIndex
    InitializeQuestIndex[Initialize quest_index = 0] --> CheckHasMoreQuests{Has More Quests?}
    CheckHasMoreQuests --> |Yes| GetNextQuest
    CheckHasMoreQuests --> |No| ProcessConclusion
    GetNextQuest[Get Quest at quest_index] --> ProcessQuestIntroduction
    ProcessQuestIntroduction[Process Quest Introduction] --> ProcessQuestDialogue
    ProcessQuestDialogue[Process Quest Dialogue] --> ProcessQuestExecution
    ProcessQuestExecution[Process Quest Execution] --> ProcessQuestCompletion
    ProcessQuestCompletion[Process Quest Completion] --> IncrementQuestIndex
    IncrementQuestIndex[Increment quest_index] --> CheckHasMoreQuests
    ProcessConclusion[Process Conclusion] --> InitializeShotIndex
    InitializeShotIndex[Save chunks.json & Initialize current_index = 0] --> CheckHasMoreChunks{Has More Chunks?}
    CheckHasMoreChunks --> |Yes| GetChunk
    CheckHasMoreChunks --> |No| End[Stop]
    GetChunk[Get Chunk at current_index] --> CreateShot
    CreateShot[Call Shot Creator Agent] --> StoreShot
    StoreShot[Add Shot to Session] --> WriteShotsFile
    WriteShotsFile[Overwrite shots.json] --> IncrementChunkIndex
    IncrementChunkIndex[Increment current_index] --> CheckHasMoreChunks
```

## State Management
The workflow maintains state across nodes using a session object that tracks chunking progress and shot generation.

### ShotCreatorSession
- It is a dataclass
- Has the following properties:
    - `subject` (str): The story subject (for file paths)
    - `story` (Story): The loaded Story object
    - `chunks` (list[Chunk]): All text chunks to process
    - `quest_index` (int): Current quest being processed during chunking phase
    - `current_quest` (Quest | None): Current quest object being processed
    - `current_index` (int): Current chunk being processed during shot creation phase
    - `shots` (list[Shot]): All generated shots
- This class is passed to each node as described in the guide

### Chunk
- It is a Pydantic BaseModel
- Has the following properties:
    - `text` (str): The text content for this chunk
    - `actor` (str): The narrator/actor name ("aaryan" for narrations, first name for dialogues)
    - `chunk_type` (str): Either "narration" or "dialogue"
    - `reference` (str): Human-readable story location (e.g., "Introduction", "Quest 1 - Dialogue")

### Shot
- It is a Pydantic BaseModel
- Has the following properties:
    - `shot_number` (int): Sequential shot number (1, 2, 3, ...)
    - `actor` (str): The voice narrator for the shot
    - `temperature` (float): Emotional intensity of the speech (0.1 - 1.0)
    - `language` (str): Language code (always "en" for English)
    - `exaggeration` (float): Dramaticness/intensity level (0.1 - 1.0)
    - `cfg_weight` (float): Speech speed control (0.1 - 1.0)
    - `text` (str): The actual narration or dialogue text content
    - `reference` (str): Story location reference (inherited from Chunk)
    - `camera_zoom` (CameraZoom): Camera framing - wide, medium, or close
    - `camera_angle` (CameraAngle): Camera position - front, front_left, left, back_left, back, back_right, right, front_right
    - `player_actions` (str): What the player should do to capture the shot (1-2 sentences max)
    - `backdrop` (str): Scene and environment description (1-2 sentences max)
    - `duration_seconds` (float): Shot duration in seconds

### Shot Duration Guidelines
Shots are created based on TTS speech timing and player action complexity:
- **Standard TTS speed**: 150 words per minute = 2.5 words per second
- **Base calculation**: `duration = word_count / 2.5`
- **Adjustments**:
    - Add 2-4 seconds for complex player actions (movement + positioning + emote)
    - Add 1-2 seconds for simple player actions (single emote or position)
    - Add 3-5 seconds for establishing shots with wide camera zoom
    - Subtract 1-2 seconds for urgent dialogue with high cfg_weight
- **Duration Ranges**:
    - Short urgent dialogue: 5-10 seconds
    - Standard dialogue: 10-15 seconds
    - Standard narration: 15-20 seconds
    - Establishing shots: 20-25 seconds
    - Maximum: 30 seconds

## The Nodes

### Phase 1: Story Chunking

### LoadStory
- Reads the story from `output/{subject}/story.json`
- The `subject` is passed during graph invocation
- Parses the JSON into a `Story` object
- Stores `subject` and `story` in `ShotCreatorSession`
- If the file does not exist, End the workflow with proper message
- If the file exists, transfer control to `InitializeChunking`

### InitializeChunking
- Initializes `ShotCreatorSession.chunks` as empty list
- Initializes `ShotCreatorSession.shots` as empty list
- **Checks if `output/{subject}/chunks.json` exists**:
    - If exists and valid: Load chunks from file, skip to `InitializeShotIndex` (bypass chunking phase)
    - If exists but invalid JSON: Print warning, regenerate chunks
    - If not exists: Continue to chunking phase
- Clears `output/{subject}/shots.json` if it exists
- Transfer control to `ProcessIntroduction` (if chunking needed) or `InitializeShotIndex` (if chunks loaded)

### ProcessIntroduction
- Checks if `story.introduction` exists
- If exists:
    - Invokes **Chunker Agent** with:
        - `text`: `story.introduction.text`
        - `chunk_type`: "narration"
        - `actor`: "aaryan"
        - `reference`: "Introduction"
    - Receives `list[Chunk]` from agent
    - Appends all chunks to `ShotCreatorSession.chunks`
- Transfer control to `InitializeQuestIndex`

### InitializeQuestIndex
- Sets `ShotCreatorSession.quest_index = 0`
- Transfer control to `CheckHasMoreQuests`

### CheckHasMoreQuests
- Checks if `quest_index < len(story.quests)`
- If yes, transfer control to `GetNextQuest`
- If no, transfer control to `ProcessConclusion`

### GetNextQuest
- Retrieves quest at `story.quests[quest_index]`
- Stores quest in `ShotCreatorSession.current_quest`
- Transfer control to `ProcessQuestIntroduction`

### ProcessQuestIntroduction
- Gets `current_quest` from `ShotCreatorSession`
- Checks if `current_quest.sections.introduction` exists
- If exists:
    - Invokes **Chunker Agent** with:
        - `text`: `current_quest.sections.introduction.text`
        - `chunk_type`: "narration"
        - `actor`: "aaryan"
        - `reference`: "Quest {quest_index + 1} - Introduction"
    - Receives `list[Chunk]` from agent
    - Appends all chunks to `ShotCreatorSession.chunks`
- Transfer control to `ProcessQuestDialogue`

### ProcessQuestDialogue
- Gets `current_quest` from `ShotCreatorSession`
- Checks if `current_quest.sections.dialogue` exists
- If exists:
    - For each `DialogueLine` in `current_quest.sections.dialogue.lines`:
        - Extract first name from `line.actor` (remove titles)
        - Invokes **Chunker Agent** with:
            - `text`: `line.line`
            - `chunk_type`: "dialogue"
            - `actor`: extracted first name
            - `reference`: "Quest {quest_index + 1} - Dialogue"
        - Receives `list[Chunk]` from agent (should be 1 chunk for dialogues)
        - Appends all chunks to `ShotCreatorSession.chunks`
- Transfer control to `ProcessQuestExecution`

### ProcessQuestExecution
- Gets `current_quest` from `ShotCreatorSession`
- Checks if `current_quest.sections.execution` exists
- If exists:
    - Invokes **Chunker Agent** with:
        - `text`: `current_quest.sections.execution.text`
        - `chunk_type`: "narration"
        - `actor`: "aaryan"
        - `reference`: "Quest {quest_index + 1} - Execution"
    - Receives `list[Chunk]` from agent
    - Appends all chunks to `ShotCreatorSession.chunks`
- Transfer control to `ProcessQuestCompletion`

### ProcessQuestCompletion
- Gets `current_quest` from `ShotCreatorSession`
- Checks if `current_quest.sections.completion` exists
- If exists:
    - For each `DialogueLine` in `current_quest.sections.completion.lines`:
        - Extract first name from `line.actor` (remove titles)
        - Invokes **Chunker Agent** with:
            - `text`: `line.line`
            - `chunk_type`: "dialogue"
            - `actor`: extracted first name
            - `reference`: "Quest {quest_index + 1} - Completion"
        - Receives `list[Chunk]` from agent (should be 1 chunk for dialogues)
        - Appends all chunks to `ShotCreatorSession.chunks`
- Transfer control to `IncrementQuestIndex`

### IncrementQuestIndex
- Increments `ShotCreatorSession.quest_index` by 1
- Transfer control to `CheckHasMoreQuests`

### ProcessConclusion
- Checks if `story.conclusion` exists
- If exists:
    - Invokes **Chunker Agent** with:
        - `text`: `story.conclusion.text`
        - `chunk_type`: "narration"
        - `actor`: "aaryan"
        - `reference`: "Conclusion"
    - Receives `list[Chunk]` from agent
    - Appends all chunks to `ShotCreatorSession.chunks`
- Transfer control to `InitializeShotIndex`

### Phase 2: Shot Creation

### InitializeShotIndex
- Saves all chunks to `output/{subject}/chunks.json` for faster re-generation
- Prints confirmation message
- **Checks if `output/{subject}/shots.json` exists**:
    - If exists and valid: Load existing shots, set `current_index = len(shots)` (resume from where it left off)
    - If exists but invalid JSON: Print warning, start from beginning with `current_index = 0`
    - If not exists: Start from beginning with `current_index = 0`
- Prints resume message if continuing from existing shots
- Transfer control to `CheckHasMoreChunks`

### CheckHasMoreChunks
- Checks if `current_index < len(chunks)`
- If yes, transfer control to `GetChunk`
- If no, transfer control to End

### GetChunk
- Retrieves chunk at `chunks[current_index]`
- Transfer control to `CreateShot` with the chunk

### CreateShot
- Invokes the **Shot Creator Agent** with the chunk
- The agent receives:
    - `text` from chunk
    - `actor` from chunk
    - `chunk_type` from chunk
    - `reference` from chunk
- The agent analyzes the text and returns a `Shot` object with:
    - `actor` (copied from chunk)
    - `temperature` (AI-determined based on emotional tone)
    - `language` (always "en")
    - `exaggeration` (AI-determined based on dramaticness)
    - `cfg_weight` (AI-determined based on pacing)
    - `text` (copied from chunk)
    - `reference` (copied from chunk)
    - `camera_zoom` (AI-determined: wide for establishing, medium for standard, close for emotional)
    - `camera_angle` (AI-determined: front, front_left, left, back_left, back, back_right, right, front_right)
    - `player_actions` (AI-determined concise instructions, max 1-2 sentences)
    - `backdrop` (AI-determined succinct description, max 1-2 sentences)
    - `duration_seconds` (AI-calculated based on word count and complexity)
- Transfer control to `StoreShot`

### StoreShot
- Calculates shot_number as `current_index + 1`
- Sets the shot_number on the Shot object
- Appends the generated Shot to `ShotCreatorSession.shots`
- Transfer control to `WriteShotsFile`

### WriteShotsFile
- Overwrites `output/{subject}/shots.json` with all shots from session
- Writes the complete `ShotCreatorSession.shots` list as JSON
- This ensures we always have the full list and don't lose data
- Transfer control to `IncrementChunkIndex`

### IncrementChunkIndex
- Increments `ShotCreatorSession.current_index` by 1
- Transfer control to `CheckHasMoreChunks`

## The AI Agents

### Chunker Agent
- AI agent that breaks the Story into meaningful chunks
- **Architecture**: Stateless agent (no session_id, no context memory)
- **LLM Provider**: OpenRouter (configured via `LLM_MODEL` environment variable)
- **Location**: `src/agents/chunker_agent/`
- **Input**: Individual text sections with metadata (text, chunk_type, actor, reference)
- **Output**: list[Chunk]
- **Responsibilities**:
    - For narrations: Break text into 15-20 second meaningful segments that don't cut off abruptly
    - For dialogues: Create one chunk per DialogueLine
    - **CRITICAL**: Remove speaker name prefixes from dialogue text (e.g., "Name:" or "Name at Location:")
    - Extract first names from actor names (remove titles like Magistrix, Ranger, Arch Mage, Huntress, Priestess)
    - Set appropriate chunk_type ("narration" or "dialogue")
    - Generate reference strings for traceability
- The system prompt follows the "GPT Identity-Purpose Template"
- The prompt explicitly mentions chunk size targets (37-50 words, 15-20 seconds at 150 words/min)
- The prompt mentions title removal rules and examples
- The prompt includes explicit instructions to strip speaker name prefixes from dialogue text

### Shot Creator Agent
- AI agent that determines TTS parameters and cinematography settings for a chunk
- **Architecture**: Stateless agent (no session_id, no context memory)
- **LLM Provider**: OpenRouter (configured via `LLM_MODEL` environment variable)
- **Location**: `src/agents/shot_creator_agent/`
- **Input**:
    - `text` (str): The chunk text
    - `actor` (str): The narrator/actor name
    - `chunk_type` (str): "narration" or "dialogue"
    - `reference` (str): Story location reference
- **Output**: Shot object
- **Responsibilities**:
    - **CRITICAL**: Strip any speaker name prefixes from text as defensive measure (last line of defense)
    - Analyze text emotional tone → determine `temperature` (0.1-1.0)
    - Analyze text dramaticness → determine `exaggeration` (0.1-1.0)
    - Analyze text pacing needs → determine `cfg_weight` (0.1-1.0)
    - Determine appropriate `camera_zoom` (wide/medium/close)
    - Determine appropriate `camera_angle` (front, front_left, left, back_left, back, back_right, right, front_right)
    - Create concise `player_actions` (1-2 sentences max)
    - Create succinct `backdrop` description (1-2 sentences max)
    - Calculate `duration_seconds` based on word count and complexity
    - Assemble complete Shot object with all fields
- The system prompt follows the "GPT Identity-Purpose Template"
- The prompt explains what each parameter means and how to determine appropriate values
- The prompt differentiates handling between narration vs dialogue chunk types
- The prompt emphasizes conciseness for player_actions and backdrop (max 1-2 sentences)
- The prompt includes duration calculation formula and adjustment guidelines
- The prompt includes TTS punctuation guidelines to avoid awkward audio splits
- **Defensive Processing**: The prompt instructs the agent to strip speaker name prefixes as a safety measure to ensure clean TTS output even if prefixes slip through from earlier stages

### TTS Text Quality Considerations

**Speaker Name Prefix Removal (Multi-layered Defense):**
- **Layer 1 (Source)**: DialogCreatorAgent instructed to NOT include speaker name prefixes in dialogue text
- **Layer 2 (Processing)**: ChunkerAgent explicitly strips any speaker name prefixes from dialogue chunks
- **Layer 3 (Defensive)**: ShotCreatorAgent strips prefixes as final safety measure before TTS processing
- **Reason**: Actor field already identifies speaker; redundant prefixes cause poor TTS output ("Sarephine: I will..." is spoken as "Sarephine colon I will...")

**TTS Punctuation Guidelines:**
The Shot Creator Agent is guided to generate TTS-friendly text:
- **Avoid semicolons** before proper nouns or capitalized words (causes TTS to split awkwardly)
- **Avoid em dashes** and complex punctuation that confuses TTS
- **Use semicolons sparingly** - only when absolutely necessary for clarity
- **Prefer commas** for light pauses and periods for sentence boundaries
- **cfg_weight guidance**: For dialogue, use 0.3-0.5 for more deliberate pacing that smooths over punctuation artifacts

## Graph Entry Point
Graph entry point should be set up in two steps:
1. Define the Graph object based on the section "## Invoking A Graph" of the Pydantic Graph blueprint
2. Create a CLI or web interface entry point to invoke the graph
3. The `subject` should be passed to the graph and set to the first node

## Resumability

The shot creator workflow is fully resumable at both the chunking and shot creation phases:

### Chunking Phase Resumability
- After chunking completes, all chunks are saved to `output/{subject}/chunks.json`
- On next run, if `chunks.json` exists:
    - System loads chunks from file
    - Skips entire chunking phase (ProcessIntroduction → ProcessConclusion)
    - Jumps directly to shot creation phase (InitializeShotIndex)
- This significantly speeds up re-generation when only shot parameters need adjustment
- To force re-chunking, delete `chunks.json` before running

### Shot Creation Phase Resumability
- After each shot is created, `shots.json` is overwritten with all shots so far
- On next run, if `shots.json` exists:
    - System loads existing shots from file
    - Sets `current_index = len(shots)` to resume from next shot
    - Continues processing remaining chunks
- This allows recovery from interruptions or errors without losing progress
- Shot numbers are calculated from `current_index + 1` to ensure correct numbering when resuming

### File Structure
```
output/{subject}/
├── story.json         (input: generated by story creator)
├── chunks.json        (saved after chunking, enables skip)
└── shots.json         (saved after each shot, enables resume)
```

## Error Handling
- For any kind of error, right now keep it KISS. Later we will put some graceful system.
- If story.json doesn't exist, end gracefully with error message
- If chunks.json is invalid JSON, print warning and regenerate chunks
- If shots.json is invalid JSON, print warning and start from beginning
- If shots.json write fails, log error but continue (will retry on next write)


